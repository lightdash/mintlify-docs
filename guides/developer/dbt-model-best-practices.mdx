---
title: dbt model best practices for Lightdash
sidebarTitle: dbt model best practice
description: Learn how to structure your dbt models for optimal performance and usability in Lightdash.
---

When building your dbt models for Lightdash, following these best practices will help you create a better experience in Lightdash for your end users and improve query performance.

## Use wide, flat tables in the BI layer

We recommend using **wide, flat tables** in the BI layer because this minimizes complex joins that need to be handled at runtime.

### Why wide tables work better

Modern columnar data warehouses (like Snowflake, BigQuery, and Redshift) are optimized for wide table formats. The star schema was initially introduced to optimize performance for row-based data warehouses, but with today's columnar warehouses, wide and flat is the way to go.

Wide tables offer several advantages:

- **Faster query performance**: Fewer joins mean faster queries at runtime
- **Better user experience**: All related fields appear together in a single section in the Lightdash sidebar, making it easier for business users to find what they need
- **Simpler to understand**: End users don't need to understand complex relationships between multiple tables
- **More accurate [AI agents](/guides/ai-agents)**: AI agents have more context when working with wide tables, so they provide more accurate answers

### How to implement wide tables

If your data is already modeled in a star schema upstream, you can maintain that structure in your transformation layer, then combine the models into wide tables that you surface in the BI layer.

Build these wider tables for key business areas where you might want specialized analysis or [AI agents](/guides/ai-agents) capabilities, such as:

- Revenue and sales
- Marketing and campaigns  
- Operations and logistics
- Customer behavior

For example, instead of having separate `orders`, `customers`, and `products` tables that need to be joined, create a wide `orders_enriched` table that includes all the relevant customer and product information alongside the order data.

## One schema.yml file per dbt model

We recommend structuring your dbt project with **one `.yml` file per model** (or `.sql` file).

This approach makes it easier to:

- Navigate through your YAML files as your project grows
- Manage and maintain individual models
- Avoid cluttered shared schema files
- Keep related configuration together

Here's an example structure:

```
models/
  orders.sql
  orders.yml
  customers.sql
  customers.yml
  products.sql
  products.yml
```

While Lightdash supports having all model definitions in a single `schema.yml` file at the directory level, we've found that separate files per model scales better as your project grows.

## What about star schema?

While we recommend wide flat tables, **we do support joins in Lightdash** and via [AI agents](/guides/ai-agents), so you have the flexibility to build out your semantic layer in a way that works best for your team.

If you're using a star schema, keep in mind:

- Fields get split into multiple sections in the Lightdash sidebar, which can be less intuitive for business users
- Cross-model references in underlying values become more complex to manage
- Now that Lightdash has fanout protection, the main performance concern with joins is mitigated

One approach is to maintain your star schema upstream for data modeling purposes, then materialize wide summary tables for specific business use cases as needed. This gives you the best of both worlds: clean data modeling practices upstream and optimized tables for BI consumption.

## Query performance considerations

All queries in Lightdash are executed against your data warehouse, so optimizing query performance directly impacts both user experience and warehouse costs.

### Minimize joins at query time

For optimal query performance, handle data transformations and complex logic directly in your SQL models rather than relying heavily on joins at query time. Pre-joining related data during your data modeling process yields better performance than joining tables on-the-fly in dashboards and reports.

If you do need joins, Lightdash offers [fanout protection](/references/joins#sql-fanouts) to help with complex relationships, but wide tables will generally perform better.

### Materialize models as tables

We recommend materializing your dbt models as [tables](https://docs.getdbt.com/docs/build/materializations#table) instead of views, especially for models that are frequently queried in Lightdash. Views execute the underlying SQL each time they're queried, which increases query time and warehouse costs.

```yaml
# In your dbt model config
{{ config(materialized='table') }}
```

For large datasets, consider using [incremental models](https://docs.getdbt.com/docs/build/incremental-models) to reduce build times while still maintaining table materialization:

```yaml
{{ config(materialized='incremental') }}
```

Run your dbt models on a schedule (e.g., daily or hourly) to keep the materialized tables fresh while reducing the query load on your warehouse.

### Leverage caching

Lightdash supports [caching](/guides/developer/caching) to reduce the number of queries executed against your warehouse. Popular charts and dashboards load faster when caching is enabled, and subsequent visits use cached results instead of querying the warehouse again.

Caching is particularly effective for:
- Frequently accessed dashboards
- Charts with stable queries (no dynamic time filters with second precision)
- Scheduled deliveries

### Reduce warehouse costs

Since all Lightdash queries run against your data warehouse, consider these strategies to manage costs:

- **Materialize frequently queried models as tables** to avoid repeated computation
- **Use incremental models** for large datasets to reduce build times
- **Enable caching** to reduce redundant queries
- **Build wide, flat tables** to minimize expensive join operations at query time
- **Schedule dbt runs** during off-peak hours when warehouse compute is cheaper (if your warehouse supports this)

### Monitor query usage

Use [query tags](/references/workspace/usage-analytics#query-tags) to monitor and analyze queries coming from Lightdash. Query tags help you:

- **Identify heavily queried tables** that may benefit from materialization or indexing
- **Spot expensive query execution plans** that could be optimized
- **Track usage patterns** to inform decisions about caching and model structure
- **Attribute warehouse costs** to specific dashboards, charts, or users

### Limit models exposed to the BI layer

Not every dbt model needs to be available in Lightdash. Limiting the models exposed to end users helps reduce confusion and ensures users are querying optimized tables.

**Option 1: Use dbt model tags**

Use [dbt tags to limit which tables appear in Lightdash](/get-started/develop-in-lightdash/adding-tables-to-lightdash#limiting-the-tables-in-lightdash-using-dbt-tags). This allows you to explicitly control which models are surfaced in the BI layer, ensuring only production-ready, optimized models are available for querying.

**Option 2: Use user attributes**

Use [user attributes](/references/workspace/user-attributes) to restrict access to specific models based on user roles or groups. This approach lets you limit end users to only the models that have been optimized for query performance, while giving power users or analysts access to a broader set of tables when needed.
